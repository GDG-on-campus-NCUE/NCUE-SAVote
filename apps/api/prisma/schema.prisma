// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// User Entity
// ============================================================================
// Represents an authenticated student who has completed SSO login.
// Stores minimal attributes extracted from SSO assertion.

enum EnrollmentStatus {
  ACTIVE
  SUSPENDED
  GRADUATED
}

enum UserRole {
  USER
  ADMIN
}

model User {
  id               String           @id @default(uuid())
  studentIdHash    String           @unique @db.VarChar(64) // SHA-256 hash (hex)
  class            String           @db.VarChar(50)         // e.g., "CSIE_3A"
  email            String?          @db.VarChar(255)        // Optional for recovery
  
  // Admin Login
  username         String?          @unique @db.VarChar(100) // Optional for admin login
  password         String?          @db.VarChar(255)         // Hashed password for admin login
  name             String?          @db.VarChar(100)         // For admins
  lastLoginIp      String?          @db.VarChar(45)          // For admins

  enrollmentStatus EnrollmentStatus @default(ACTIVE)
  role             UserRole         @default(USER)
  
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  
  // Relations
  sessions         Session[]
  adminLoginLogs   AdminLoginLog[]
  
  @@index([class])
  @@index([role])
  @@map("users")
}

// ============================================================================
// Admin Login Log Entity
// ============================================================================
model AdminLoginLog {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  ipAddress String   @db.VarChar(45)
  loginAt   DateTime @default(now())
  
  @@index([userId])
  @@map("admin_login_logs")
}

// ============================================================================
// Session Entity
// ============================================================================
// Tracks active JWT sessions for access token revocation and refresh token management.

model Session {
  id             String    @id @default(uuid())
  userId         String
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  jti            String    @unique @db.VarChar(36) // JWT ID (UUID format)
  accessToken    String    @db.Text
  refreshToken   String    @db.Text
  expiresAt      DateTime
  revoked        Boolean   @default(false)
  revokedAt      DateTime?
  deviceInfo     String?   @db.VarChar(500)
  ipAddress      String?   @db.VarChar(45) // IPv6 max length
  createdAt      DateTime  @default(now())
  lastActivityAt DateTime  @default(now())
  
  @@index([userId, revoked])
  @@index([jti])
  @@index([expiresAt]) // For cleanup job
  @@map("sessions")
}

// ============================================================================
// Election Entity
// ============================================================================
// Represents a voting election. Merkle root hash field for eligibility verification.

enum ElectionType {
  PRESIDENTIAL
  DISTRICT_COUNCILOR
  AT_LARGE_COUNCILOR
}

model Election {
  id              String          @id @default(uuid())
  name            String          @db.VarChar(255)
  description     String?         @db.Text
  type            ElectionType    @default(PRESIDENTIAL)
  config          Json?           // Stores specific rules (thresholds, seats, etc.)

  // ZK Config
  merkleRoot      String?         @db.VarChar(100) // Root of the voter tree at snapshot time
  merkleTreeDepth Int             @default(20)
  
  status          ElectionStatus  @default(DRAFT)
  startTime       DateTime?
  endTime         DateTime?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  
  // Relations
  eligibleVoters  EligibleVoter[]
  candidates      Candidate[]
  votes           Vote[]
  
  @@index([status])
  @@index([startTime, endTime])
  @@map("elections")
}

enum ElectionStatus {
  DRAFT
  REGISTRATION_OPEN
  VOTING_OPEN
  VOTING_CLOSED
  TALLIED
}

// ============================================================================
// EligibleVoter Entity
// ============================================================================
// Stores the list of students eligible to vote in a specific election.
// Imported by Admin. 

model EligibleVoter {
  id         String   @id @default(uuid())
  studentId  String   @db.VarChar(20)  // Plaintext student ID (for management)
  class      String   @db.VarChar(50)
  
  // ZK Registration
  identityCommitment String? @db.VarChar(100) // The ZK commitment

  electionId String
  election   Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@unique([studentId, electionId]) // One entry per student per election
  @@index([electionId])
  @@index([studentId])
  @@map("eligible_voters")
}

// ============================================================================
// Candidate Entity
// ============================================================================
// Represents a candidate in an election.

model Candidate {
  id          String   @id @default(uuid())
  name        String   @db.VarChar(100)
  bio         String?  @db.Text
  photoUrl    String?  @db.VarChar(500)
  electionId  String
  election    Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  receivedVotes Vote[]

  @@index([electionId])
  @@map("candidates")
}

// ============================================================================
// Vote Entity
// ============================================================================
// Stores the zero-knowledge proof and nullifier for a cast vote.
// Does NOT link to a User or Student ID to ensure anonymity.

model Vote {
  id            String   @id @default(uuid())
  electionId    String
  election      Election @relation(fields: [electionId], references: [id], onDelete: Cascade)
  
  // The candidate voted for (extracted from proof for easy tallying)
  // Note: The proof verifies that this candidateId matches the one in publicSignals
  candidateId   String
  candidate     Candidate @relation(fields: [candidateId], references: [id])

  // ZK Proof Data
  nullifierHash String   @db.VarChar(100) // Prevents double voting (unique per election)
  proof         Json     // The Groth16 proof object
  publicSignals Json     // Public inputs
  
  createdAt     DateTime @default(now())

  @@unique([electionId, nullifierHash]) // Ensure uniqueness per election
  @@index([electionId])
  @@map("votes")
}